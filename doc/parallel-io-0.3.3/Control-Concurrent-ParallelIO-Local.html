<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Control.Concurrent.ParallelIO.Local</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">parallel-io-0.3.3: Combinators for executing IO actions in parallel on a thread pool.</span><ul class="links" id="page-menu"><li><a href="src/Control.Concurrent.ParallelIO.Local.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe</td></tr><tr><th>Language</th><td>Haskell98</td></tr></table><p class="caption">Control.Concurrent.ParallelIO.Local</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Executing actions</a></li><li><a href="#g:2">Pool management</a></li><li><a href="#g:3">Advanced pool management</a></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Parallelism combinators with explicit thread-pool creation and
 passing.</p><p>The most basic example of usage is:</p><pre>main = withPool 2 $ \pool -&gt; parallel_ pool [putStrLn &quot;Echo&quot;, putStrLn &quot; in parallel&quot;]</pre><p>Make sure that you compile with <code>-threaded</code> and supply <code>+RTS -N2 -RTS</code>
 to  the generated Haskell executable, or you won't get any parallelism.</p><p>If you plan to allow your worker items to block, then you should read the documentation for <code><a href="Control-Concurrent-ParallelIO-Local.html#v:extraWorkerWhileBlocked" title="Control.Concurrent.ParallelIO.Local">extraWorkerWhileBlocked</a></code>.</p><p>The <a href="Control-Concurrent-ParallelIO-Global.html">Control.Concurrent.ParallelIO.Global</a> module is implemented
 on top of this one by maintaining a shared global thread pool
 with one thread per capability.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:parallel_">parallel_</a> :: <a href="Control-Concurrent-ParallelIO-Local.html#t:Pool" title="Control.Concurrent.ParallelIO.Local">Pool</a> -&gt; [<a href="../base-4.13.0.0/System-IO.html#t:IO" title="System.IO">IO</a> a] -&gt; <a href="../base-4.13.0.0/System-IO.html#t:IO" title="System.IO">IO</a> ()</li><li class="src short"><a href="#v:parallelE_">parallelE_</a> :: <a href="Control-Concurrent-ParallelIO-Local.html#t:Pool" title="Control.Concurrent.ParallelIO.Local">Pool</a> -&gt; [<a href="../base-4.13.0.0/System-IO.html#t:IO" title="System.IO">IO</a> a] -&gt; <a href="../base-4.13.0.0/System-IO.html#t:IO" title="System.IO">IO</a> [<a href="../base-4.13.0.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="../base-4.13.0.0/Control-Exception-Base.html#t:SomeException" title="Control.Exception.Base">SomeException</a>]</li><li class="src short"><a href="#v:parallel">parallel</a> :: <a href="Control-Concurrent-ParallelIO-Local.html#t:Pool" title="Control.Concurrent.ParallelIO.Local">Pool</a> -&gt; [<a href="../base-4.13.0.0/System-IO.html#t:IO" title="System.IO">IO</a> a] -&gt; <a href="../base-4.13.0.0/System-IO.html#t:IO" title="System.IO">IO</a> [a]</li><li class="src short"><a href="#v:parallelE">parallelE</a> :: <a href="Control-Concurrent-ParallelIO-Local.html#t:Pool" title="Control.Concurrent.ParallelIO.Local">Pool</a> -&gt; [<a href="../base-4.13.0.0/System-IO.html#t:IO" title="System.IO">IO</a> a] -&gt; <a href="../base-4.13.0.0/System-IO.html#t:IO" title="System.IO">IO</a> [<a href="../base-4.13.0.0/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="../base-4.13.0.0/Control-Exception-Base.html#t:SomeException" title="Control.Exception.Base">SomeException</a> a]</li><li class="src short"><a href="#v:parallelInterleaved">parallelInterleaved</a> :: <a href="Control-Concurrent-ParallelIO-Local.html#t:Pool" title="Control.Concurrent.ParallelIO.Local">Pool</a> -&gt; [<a href="../base-4.13.0.0/System-IO.html#t:IO" title="System.IO">IO</a> a] -&gt; <a href="../base-4.13.0.0/System-IO.html#t:IO" title="System.IO">IO</a> [a]</li><li class="src short"><a href="#v:parallelInterleavedE">parallelInterleavedE</a> :: <a href="Control-Concurrent-ParallelIO-Local.html#t:Pool" title="Control.Concurrent.ParallelIO.Local">Pool</a> -&gt; [<a href="../base-4.13.0.0/System-IO.html#t:IO" title="System.IO">IO</a> a] -&gt; <a href="../base-4.13.0.0/System-IO.html#t:IO" title="System.IO">IO</a> [<a href="../base-4.13.0.0/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="../base-4.13.0.0/Control-Exception-Base.html#t:SomeException" title="Control.Exception.Base">SomeException</a> a]</li><li class="src short"><a href="#v:parallelFirst">parallelFirst</a> :: <a href="Control-Concurrent-ParallelIO-Local.html#t:Pool" title="Control.Concurrent.ParallelIO.Local">Pool</a> -&gt; [<a href="../base-4.13.0.0/System-IO.html#t:IO" title="System.IO">IO</a> (<a href="../base-4.13.0.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a)] -&gt; <a href="../base-4.13.0.0/System-IO.html#t:IO" title="System.IO">IO</a> (<a href="../base-4.13.0.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a)</li><li class="src short"><a href="#v:parallelFirstE">parallelFirstE</a> :: <a href="Control-Concurrent-ParallelIO-Local.html#t:Pool" title="Control.Concurrent.ParallelIO.Local">Pool</a> -&gt; [<a href="../base-4.13.0.0/System-IO.html#t:IO" title="System.IO">IO</a> (<a href="../base-4.13.0.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a)] -&gt; <a href="../base-4.13.0.0/System-IO.html#t:IO" title="System.IO">IO</a> (<a href="../base-4.13.0.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (<a href="../base-4.13.0.0/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="../base-4.13.0.0/Control-Exception-Base.html#t:SomeException" title="Control.Exception.Base">SomeException</a> a))</li><li class="src short"><span class="keyword">data</span> <a href="#t:Pool">Pool</a></li><li class="src short"><a href="#v:withPool">withPool</a> :: <a href="../base-4.13.0.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; (<a href="Control-Concurrent-ParallelIO-Local.html#t:Pool" title="Control.Concurrent.ParallelIO.Local">Pool</a> -&gt; <a href="../base-4.13.0.0/System-IO.html#t:IO" title="System.IO">IO</a> a) -&gt; <a href="../base-4.13.0.0/System-IO.html#t:IO" title="System.IO">IO</a> a</li><li class="src short"><a href="#v:startPool">startPool</a> :: <a href="../base-4.13.0.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="../base-4.13.0.0/System-IO.html#t:IO" title="System.IO">IO</a> <a href="Control-Concurrent-ParallelIO-Local.html#t:Pool" title="Control.Concurrent.ParallelIO.Local">Pool</a></li><li class="src short"><a href="#v:stopPool">stopPool</a> :: <a href="Control-Concurrent-ParallelIO-Local.html#t:Pool" title="Control.Concurrent.ParallelIO.Local">Pool</a> -&gt; <a href="../base-4.13.0.0/System-IO.html#t:IO" title="System.IO">IO</a> ()</li><li class="src short"><a href="#v:extraWorkerWhileBlocked">extraWorkerWhileBlocked</a> :: <a href="Control-Concurrent-ParallelIO-Local.html#t:Pool" title="Control.Concurrent.ParallelIO.Local">Pool</a> -&gt; <a href="../base-4.13.0.0/System-IO.html#t:IO" title="System.IO">IO</a> a -&gt; <a href="../base-4.13.0.0/System-IO.html#t:IO" title="System.IO">IO</a> a</li><li class="src short"><a href="#v:spawnPoolWorkerFor">spawnPoolWorkerFor</a> :: <a href="Control-Concurrent-ParallelIO-Local.html#t:Pool" title="Control.Concurrent.ParallelIO.Local">Pool</a> -&gt; <a href="../base-4.13.0.0/System-IO.html#t:IO" title="System.IO">IO</a> ()</li><li class="src short"><a href="#v:killPoolWorkerFor">killPoolWorkerFor</a> :: <a href="Control-Concurrent-ParallelIO-Local.html#t:Pool" title="Control.Concurrent.ParallelIO.Local">Pool</a> -&gt; <a href="../base-4.13.0.0/System-IO.html#t:IO" title="System.IO">IO</a> ()</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Executing actions</h1></a><div class="top"><p class="src"><a id="v:parallel_" class="def">parallel_</a> :: <a href="Control-Concurrent-ParallelIO-Local.html#t:Pool" title="Control.Concurrent.ParallelIO.Local">Pool</a> -&gt; [<a href="../base-4.13.0.0/System-IO.html#t:IO" title="System.IO">IO</a> a] -&gt; <a href="../base-4.13.0.0/System-IO.html#t:IO" title="System.IO">IO</a> () <a href="src/Control.Concurrent.ParallelIO.Local.html#parallel_" class="link">Source</a> <a href="#v:parallel_" class="selflink">#</a></p><div class="doc"><p>Run the list of computations in parallel.</p><p>Has the following properties:</p><ol><li>Never creates more or less unblocked threads than are specified to
     live in the pool. NB: this count includes the thread executing <code><a href="Control-Concurrent-ParallelIO-Local.html#v:parallel_" title="Control.Concurrent.ParallelIO.Local">parallel_</a></code>.
     This should minimize contention and hence pre-emption, while also preventing
     starvation.</li><li>On return all actions have been performed.</li><li>The function returns in a timely manner as soon as all actions have
     been performed.</li><li>The above properties are true even if <code><a href="Control-Concurrent-ParallelIO-Local.html#v:parallel_" title="Control.Concurrent.ParallelIO.Local">parallel_</a></code> is used by an
     action which is itself being executed by one of the parallel combinators.</li><li>If any of the IO actions throws an exception this does not prevent any of the
     other actions from being performed.</li><li>If any of the IO actions throws an exception, the exception thrown by the first
     failing action in the input list will be thrown by <code><a href="Control-Concurrent-ParallelIO-Local.html#v:parallel_" title="Control.Concurrent.ParallelIO.Local">parallel_</a></code>. Importantly, at the
     time the exception is thrown there is no guarantee that the other parallel actions
     have completed.</li></ol><p>The motivation for this choice is that waiting for the all threads to either return
     or throw before throwing the first exception will almost always cause GHC to show the
     &quot;Blocked indefinitely in MVar operation&quot; exception rather than the exception you care about.</p><p>The reason for this behaviour can be seen by considering this machine state:</p><ol><li>The main thread has used the parallel combinators to spawn two threads, thread 1 and thread 2.
          It is blocked on both of them waiting for them to return either a result or an exception via an MVar.</li><li>Thread 1 and thread 2 share another (empty) MVar, the &quot;wait handle&quot;. Thread 2 is waiting on the handle,
          while thread 2 will eventually put into the handle.</li></ol><p>Consider what happens when thread 1 is buggy and throws an exception before putting into the handle. Now
     thread 2 is blocked indefinitely, and so the main thread is also blocked indefinetly waiting for the result
     of thread 2. GHC has no choice but to throw the uninformative exception. However, what we really wanted to
     see was the original exception thrown in thread 1!</p><p>By having the main thread abandon its wait for the results of the spawned threads as soon as the first exception
     comes in, we give this exception a chance to actually be displayed.</p></div></div><div class="top"><p class="src"><a id="v:parallelE_" class="def">parallelE_</a> :: <a href="Control-Concurrent-ParallelIO-Local.html#t:Pool" title="Control.Concurrent.ParallelIO.Local">Pool</a> -&gt; [<a href="../base-4.13.0.0/System-IO.html#t:IO" title="System.IO">IO</a> a] -&gt; <a href="../base-4.13.0.0/System-IO.html#t:IO" title="System.IO">IO</a> [<a href="../base-4.13.0.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="../base-4.13.0.0/Control-Exception-Base.html#t:SomeException" title="Control.Exception.Base">SomeException</a>] <a href="src/Control.Concurrent.ParallelIO.Local.html#parallelE_" class="link">Source</a> <a href="#v:parallelE_" class="selflink">#</a></p><div class="doc"><p>As <code><a href="Control-Concurrent-ParallelIO-Local.html#v:parallel_" title="Control.Concurrent.ParallelIO.Local">parallel_</a></code>, but instead of throwing exceptions that are thrown by subcomputations,
 they are returned in a data structure.</p><p>As a result, property 6 of <code><a href="Control-Concurrent-ParallelIO-Local.html#v:parallel_" title="Control.Concurrent.ParallelIO.Local">parallel_</a></code> is not preserved, and therefore if your IO actions can depend on each other
 and may throw exceptions your program may die with &quot;blocked indefinitely&quot; exceptions rather than informative messages.</p></div></div><div class="top"><p class="src"><a id="v:parallel" class="def">parallel</a> :: <a href="Control-Concurrent-ParallelIO-Local.html#t:Pool" title="Control.Concurrent.ParallelIO.Local">Pool</a> -&gt; [<a href="../base-4.13.0.0/System-IO.html#t:IO" title="System.IO">IO</a> a] -&gt; <a href="../base-4.13.0.0/System-IO.html#t:IO" title="System.IO">IO</a> [a] <a href="src/Control.Concurrent.ParallelIO.Local.html#parallel" class="link">Source</a> <a href="#v:parallel" class="selflink">#</a></p><div class="doc"><p>Run the list of computations in parallel, returning the results in the
 same order as the corresponding actions.</p><p>Has the following properties:</p><ol><li>Never creates more or less unblocked threads than are specified to
     live in the pool. NB: this count includes the thread executing <code><a href="Control-Concurrent-ParallelIO-Local.html#v:parallel" title="Control.Concurrent.ParallelIO.Local">parallel</a></code>.
     This should minimize contention and hence pre-emption, while also preventing
     starvation.</li><li>On return all actions have been performed.</li><li>The function returns in a timely manner as soon as all actions have
     been performed.</li><li>The above properties are true even if <code><a href="Control-Concurrent-ParallelIO-Local.html#v:parallel" title="Control.Concurrent.ParallelIO.Local">parallel</a></code> is used by an
     action which is itself being executed by one of the parallel combinators.</li><li>If any of the IO actions throws an exception this does not prevent any of the
     other actions from being performed.</li><li>If any of the IO actions throws an exception, the exception thrown by the first
     failing action in the input list will be thrown by <code><a href="Control-Concurrent-ParallelIO-Local.html#v:parallel" title="Control.Concurrent.ParallelIO.Local">parallel</a></code>. Importantly, at the
     time the exception is thrown there is no guarantee that the other parallel actions
     have completed.</li></ol><p>The motivation for this choice is that waiting for the all threads to either return
     or throw before throwing the first exception will almost always cause GHC to show the
     &quot;Blocked indefinitely in MVar operation&quot; exception rather than the exception you care about.</p><p>The reason for this behaviour can be seen by considering this machine state:</p><ol><li>The main thread has used the parallel combinators to spawn two threads, thread 1 and thread 2.
          It is blocked on both of them waiting for them to return either a result or an exception via an MVar.</li><li>Thread 1 and thread 2 share another (empty) MVar, the &quot;wait handle&quot;. Thread 2 is waiting on the handle,
          while thread 2 will eventually put into the handle.</li></ol><p>Consider what happens when thread 1 is buggy and throws an exception before putting into the handle. Now
     thread 2 is blocked indefinitely, and so the main thread is also blocked indefinetly waiting for the result
     of thread 2. GHC has no choice but to throw the uninformative exception. However, what we really wanted to
     see was the original exception thrown in thread 1!</p><p>By having the main thread abandon its wait for the results of the spawned threads as soon as the first exception
     comes in, we give this exception a chance to actually be displayed.</p></div></div><div class="top"><p class="src"><a id="v:parallelE" class="def">parallelE</a> :: <a href="Control-Concurrent-ParallelIO-Local.html#t:Pool" title="Control.Concurrent.ParallelIO.Local">Pool</a> -&gt; [<a href="../base-4.13.0.0/System-IO.html#t:IO" title="System.IO">IO</a> a] -&gt; <a href="../base-4.13.0.0/System-IO.html#t:IO" title="System.IO">IO</a> [<a href="../base-4.13.0.0/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="../base-4.13.0.0/Control-Exception-Base.html#t:SomeException" title="Control.Exception.Base">SomeException</a> a] <a href="src/Control.Concurrent.ParallelIO.Local.html#parallelE" class="link">Source</a> <a href="#v:parallelE" class="selflink">#</a></p><div class="doc"><p>As <code><a href="Control-Concurrent-ParallelIO-Local.html#v:parallel" title="Control.Concurrent.ParallelIO.Local">parallel</a></code>, but instead of throwing exceptions that are thrown by subcomputations,
 they are returned in a data structure.</p><p>As a result, property 6 of <code><a href="Control-Concurrent-ParallelIO-Local.html#v:parallel" title="Control.Concurrent.ParallelIO.Local">parallel</a></code> is not preserved, and therefore if your IO actions can depend on each other
 and may throw exceptions your program may die with &quot;blocked indefinitely&quot; exceptions rather than informative messages.</p></div></div><div class="top"><p class="src"><a id="v:parallelInterleaved" class="def">parallelInterleaved</a> :: <a href="Control-Concurrent-ParallelIO-Local.html#t:Pool" title="Control.Concurrent.ParallelIO.Local">Pool</a> -&gt; [<a href="../base-4.13.0.0/System-IO.html#t:IO" title="System.IO">IO</a> a] -&gt; <a href="../base-4.13.0.0/System-IO.html#t:IO" title="System.IO">IO</a> [a] <a href="src/Control.Concurrent.ParallelIO.Local.html#parallelInterleaved" class="link">Source</a> <a href="#v:parallelInterleaved" class="selflink">#</a></p><div class="doc"><p>Run the list of computations in parallel, returning the results in the
 approximate order of completion.</p><p>Has the following properties:</p><ol><li>Never creates more or less unblocked threads than are specified to
     live in the pool. NB: this count includes the thread executing <code><a href="Control-Concurrent-ParallelIO-Local.html#v:parallelInterleaved" title="Control.Concurrent.ParallelIO.Local">parallelInterleaved</a></code>.
     This should minimize contention and hence pre-emption, while also preventing
     starvation.</li><li>On return all actions have been performed.</li><li>The result of running actions appear in the list in undefined order, but which
     is likely to be very similar to the order of completion.</li><li>The above properties are true even if <code><a href="Control-Concurrent-ParallelIO-Local.html#v:parallelInterleaved" title="Control.Concurrent.ParallelIO.Local">parallelInterleaved</a></code> is used by an
     action which is itself being executed by one of the parallel combinators.</li><li>If any of the IO actions throws an exception this does not prevent any of the
     other actions from being performed.</li><li>If any of the IO actions throws an exception, the exception thrown by the first
     failing action in the input list will be thrown by <code><a href="Control-Concurrent-ParallelIO-Local.html#v:parallelInterleaved" title="Control.Concurrent.ParallelIO.Local">parallelInterleaved</a></code>. Importantly, at the
     time the exception is thrown there is no guarantee that the other parallel actions
     have completed.</li></ol><p>The motivation for this choice is that waiting for the all threads to either return
     or throw before throwing the first exception will almost always cause GHC to show the
     &quot;Blocked indefinitely in MVar operation&quot; exception rather than the exception you care about.</p><p>The reason for this behaviour can be seen by considering this machine state:</p><ol><li>The main thread has used the parallel combinators to spawn two threads, thread 1 and thread 2.
          It is blocked on both of them waiting for them to return either a result or an exception via an MVar.</li><li>Thread 1 and thread 2 share another (empty) MVar, the &quot;wait handle&quot;. Thread 2 is waiting on the handle,
          while thread 1 will eventually put into the handle.</li></ol><p>Consider what happens when thread 1 is buggy and throws an exception before putting into the handle. Now
     thread 2 is blocked indefinitely, and so the main thread is also blocked indefinetly waiting for the result
     of thread 2. GHC has no choice but to throw the uninformative exception. However, what we really wanted to
     see was the original exception thrown in thread 1!</p><p>By having the main thread abandon its wait for the results of the spawned threads as soon as the first exception
     comes in, we give this exception a chance to actually be displayed.</p></div></div><div class="top"><p class="src"><a id="v:parallelInterleavedE" class="def">parallelInterleavedE</a> :: <a href="Control-Concurrent-ParallelIO-Local.html#t:Pool" title="Control.Concurrent.ParallelIO.Local">Pool</a> -&gt; [<a href="../base-4.13.0.0/System-IO.html#t:IO" title="System.IO">IO</a> a] -&gt; <a href="../base-4.13.0.0/System-IO.html#t:IO" title="System.IO">IO</a> [<a href="../base-4.13.0.0/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="../base-4.13.0.0/Control-Exception-Base.html#t:SomeException" title="Control.Exception.Base">SomeException</a> a] <a href="src/Control.Concurrent.ParallelIO.Local.html#parallelInterleavedE" class="link">Source</a> <a href="#v:parallelInterleavedE" class="selflink">#</a></p><div class="doc"><p>As <code><a href="Control-Concurrent-ParallelIO-Local.html#v:parallelInterleaved" title="Control.Concurrent.ParallelIO.Local">parallelInterleaved</a></code>, but instead of throwing exceptions that are thrown by subcomputations,
 they are returned in a data structure.</p><p>As a result, property 6 of <code><a href="Control-Concurrent-ParallelIO-Local.html#v:parallelInterleaved" title="Control.Concurrent.ParallelIO.Local">parallelInterleaved</a></code> is not preserved, and therefore if your IO actions can depend on each other
 and may throw exceptions your program may die with &quot;blocked indefinitely&quot; exceptions rather than informative messages.</p></div></div><div class="top"><p class="src"><a id="v:parallelFirst" class="def">parallelFirst</a> :: <a href="Control-Concurrent-ParallelIO-Local.html#t:Pool" title="Control.Concurrent.ParallelIO.Local">Pool</a> -&gt; [<a href="../base-4.13.0.0/System-IO.html#t:IO" title="System.IO">IO</a> (<a href="../base-4.13.0.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a)] -&gt; <a href="../base-4.13.0.0/System-IO.html#t:IO" title="System.IO">IO</a> (<a href="../base-4.13.0.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a) <a href="src/Control.Concurrent.ParallelIO.Local.html#parallelFirst" class="link">Source</a> <a href="#v:parallelFirst" class="selflink">#</a></p><div class="doc"><p>Run the list of computations in parallel, returning the result of the first
 thread that completes with (Just x), if any</p><p>Has the following properties:</p><ol><li>Never creates more or less unblocked threads than are specified to
     live in the pool. NB: this count includes the thread executing <code><a href="Control-Concurrent-ParallelIO-Local.html#v:parallelInterleaved" title="Control.Concurrent.ParallelIO.Local">parallelInterleaved</a></code>.
     This should minimize contention and hence pre-emption, while also preventing
     starvation.</li><li>On return all actions have either been performed or cancelled (with ThreadKilled exceptions).</li><li>The above properties are true even if <code><a href="Control-Concurrent-ParallelIO-Local.html#v:parallelFirst" title="Control.Concurrent.ParallelIO.Local">parallelFirst</a></code> is used by an
     action which is itself being executed by one of the parallel combinators.</li><li>If any of the IO actions throws an exception, the exception thrown by the first
     throwing action in the input list will be thrown by <code><a href="Control-Concurrent-ParallelIO-Local.html#v:parallelFirst" title="Control.Concurrent.ParallelIO.Local">parallelFirst</a></code>. Importantly, at the
     time the exception is thrown there is no guarantee that the other parallel actions
     have been completed or cancelled.</li></ol><p>The motivation for this choice is that waiting for the all threads to either return
     or throw before throwing the first exception will almost always cause GHC to show the
     &quot;Blocked indefinitely in MVar operation&quot; exception rather than the exception you care about.</p><p>The reason for this behaviour can be seen by considering this machine state:</p><ol><li>The main thread has used the parallel combinators to spawn two threads, thread 1 and thread 2.
          It is blocked on both of them waiting for them to return either a result or an exception via an MVar.</li><li>Thread 1 and thread 2 share another (empty) MVar, the &quot;wait handle&quot;. Thread 2 is waiting on the handle,
          while thread 1 will eventually put into the handle.</li></ol><p>Consider what happens when thread 1 is buggy and throws an exception before putting into the handle. Now
     thread 2 is blocked indefinitely, and so the main thread is also blocked indefinetly waiting for the result
     of thread 2. GHC has no choice but to throw the uninformative exception. However, what we really wanted to
     see was the original exception thrown in thread 1!</p><p>By having the main thread abandon its wait for the results of the spawned threads as soon as the first exception
     comes in, we give this exception a chance to actually be displayed.</p></div></div><div class="top"><p class="src"><a id="v:parallelFirstE" class="def">parallelFirstE</a> :: <a href="Control-Concurrent-ParallelIO-Local.html#t:Pool" title="Control.Concurrent.ParallelIO.Local">Pool</a> -&gt; [<a href="../base-4.13.0.0/System-IO.html#t:IO" title="System.IO">IO</a> (<a href="../base-4.13.0.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a)] -&gt; <a href="../base-4.13.0.0/System-IO.html#t:IO" title="System.IO">IO</a> (<a href="../base-4.13.0.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (<a href="../base-4.13.0.0/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="../base-4.13.0.0/Control-Exception-Base.html#t:SomeException" title="Control.Exception.Base">SomeException</a> a)) <a href="src/Control.Concurrent.ParallelIO.Local.html#parallelFirstE" class="link">Source</a> <a href="#v:parallelFirstE" class="selflink">#</a></p><div class="doc"><p>As <code><a href="Control-Concurrent-ParallelIO-Local.html#v:parallelFirst" title="Control.Concurrent.ParallelIO.Local">parallelFirst</a></code>, but instead of throwing exceptions that are thrown by subcomputations,
 they are returned in a data structure.</p><p>As a result, property 4 of <code><a href="Control-Concurrent-ParallelIO-Local.html#v:parallelFirst" title="Control.Concurrent.ParallelIO.Local">parallelFirst</a></code> is not preserved, and therefore if your IO actions can depend on each other
 and may throw exceptions your program may die with &quot;blocked indefinitely&quot; exceptions rather than informative messages.</p></div></div><a href="#g:2" id="g:2"><h1>Pool management</h1></a><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Pool" class="def">Pool</a> <a href="src/Control.Concurrent.ParallelIO.Local.html#Pool" class="link">Source</a> <a href="#t:Pool" class="selflink">#</a></p><div class="doc"><p>A thread pool, containing a maximum number of threads. The best way to
 construct one of these is using <code><a href="Control-Concurrent-ParallelIO-Local.html#v:withPool" title="Control.Concurrent.ParallelIO.Local">withPool</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:withPool" class="def">withPool</a> :: <a href="../base-4.13.0.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; (<a href="Control-Concurrent-ParallelIO-Local.html#t:Pool" title="Control.Concurrent.ParallelIO.Local">Pool</a> -&gt; <a href="../base-4.13.0.0/System-IO.html#t:IO" title="System.IO">IO</a> a) -&gt; <a href="../base-4.13.0.0/System-IO.html#t:IO" title="System.IO">IO</a> a <a href="src/Control.Concurrent.ParallelIO.Local.html#withPool" class="link">Source</a> <a href="#v:withPool" class="selflink">#</a></p><div class="doc"><p>A safe wrapper around <code><a href="Control-Concurrent-ParallelIO-Local.html#v:startPool" title="Control.Concurrent.ParallelIO.Local">startPool</a></code> and <code><a href="Control-Concurrent-ParallelIO-Local.html#v:stopPool" title="Control.Concurrent.ParallelIO.Local">stopPool</a></code>. Executes an <code><a href="../base-4.13.0.0/System-IO.html#t:IO" title="System.IO">IO</a></code> action using a newly-created
 pool with the specified number of threads and cleans it up at the end.</p></div></div><div class="top"><p class="src"><a id="v:startPool" class="def">startPool</a> :: <a href="../base-4.13.0.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="../base-4.13.0.0/System-IO.html#t:IO" title="System.IO">IO</a> <a href="Control-Concurrent-ParallelIO-Local.html#t:Pool" title="Control.Concurrent.ParallelIO.Local">Pool</a> <a href="src/Control.Concurrent.ParallelIO.Local.html#startPool" class="link">Source</a> <a href="#v:startPool" class="selflink">#</a></p><div class="doc"><p>A slightly unsafe way to construct a pool. Make a pool from the maximum
 number of threads you wish it to execute (including the main thread
 in the count).</p><p>If you use this variant then ensure that you insert a call to <code><a href="Control-Concurrent-ParallelIO-Local.html#v:stopPool" title="Control.Concurrent.ParallelIO.Local">stopPool</a></code>
 somewhere in your program after all users of that pool have finished.</p><p>A better alternative is to see if you can use the <code><a href="Control-Concurrent-ParallelIO-Local.html#v:withPool" title="Control.Concurrent.ParallelIO.Local">withPool</a></code> variant.</p></div></div><div class="top"><p class="src"><a id="v:stopPool" class="def">stopPool</a> :: <a href="Control-Concurrent-ParallelIO-Local.html#t:Pool" title="Control.Concurrent.ParallelIO.Local">Pool</a> -&gt; <a href="../base-4.13.0.0/System-IO.html#t:IO" title="System.IO">IO</a> () <a href="src/Control.Concurrent.ParallelIO.Local.html#stopPool" class="link">Source</a> <a href="#v:stopPool" class="selflink">#</a></p><div class="doc"><p>Clean up a thread pool. If you don't call this from the main thread then no one holds the queue,
 the queue gets GC'd, the threads find themselves blocked indefinitely, and you get exceptions.</p><p>This cleanly shuts down the threads so the queue isn't important and you don't get
 exceptions.</p><p>Only call this <em>after</em> all users of the pool have completed, or your program may
 block indefinitely.</p></div></div><div class="top"><p class="src"><a id="v:extraWorkerWhileBlocked" class="def">extraWorkerWhileBlocked</a> :: <a href="Control-Concurrent-ParallelIO-Local.html#t:Pool" title="Control.Concurrent.ParallelIO.Local">Pool</a> -&gt; <a href="../base-4.13.0.0/System-IO.html#t:IO" title="System.IO">IO</a> a -&gt; <a href="../base-4.13.0.0/System-IO.html#t:IO" title="System.IO">IO</a> a <a href="src/Control.Concurrent.ParallelIO.Local.html#extraWorkerWhileBlocked" class="link">Source</a> <a href="#v:extraWorkerWhileBlocked" class="selflink">#</a></p><div class="doc"><p>You should wrap any IO action used from your worker threads that may block with this method.
 It temporarily spawns another worker thread to make up for the loss of the old blocked
 worker.</p><p>This is particularly important if the unblocking is dependent on worker threads actually doing
 work. If you have this situation, and you don't use this method to wrap blocking actions, then
 you may get a deadlock if all your worker threads get blocked on work that they assume will be
 done by other worker threads.</p><p>An example where something goes wrong if you don't use this to wrap blocking actions is the following example:</p><pre>newEmptyMVar &gt;&gt;= \mvar -&gt; parallel_ pool [readMVar mvar, putMVar mvar ()]</pre><p>If we only have one thread, we will sometimes get a schedule where the <code><a href="../base-4.13.0.0/Control-Concurrent-MVar.html#v:readMVar" title="Control.Concurrent.MVar">readMVar</a></code> action is run
 before the <code><a href="../base-4.13.0.0/Control-Concurrent-MVar.html#v:putMVar" title="Control.Concurrent.MVar">putMVar</a></code>. Unless we wrap the read with <code><a href="Control-Concurrent-ParallelIO-Local.html#v:extraWorkerWhileBlocked" title="Control.Concurrent.ParallelIO.Local">extraWorkerWhileBlocked</a></code>, if the pool has a
 single thread our program to deadlock, because the worker will become blocked and no other thread
 will be available to execute the <code><a href="../base-4.13.0.0/Control-Concurrent-MVar.html#v:putMVar" title="Control.Concurrent.MVar">putMVar</a></code>.</p><p>The correct code is:</p><pre>newEmptyMVar &gt;&gt;= \mvar -&gt; parallel_ pool [extraWorkerWhileBlocked pool (readMVar mvar), putMVar mvar ()]</pre></div></div><a href="#g:3" id="g:3"><h1>Advanced pool management</h1></a><div class="top"><p class="src"><a id="v:spawnPoolWorkerFor" class="def">spawnPoolWorkerFor</a> :: <a href="Control-Concurrent-ParallelIO-Local.html#t:Pool" title="Control.Concurrent.ParallelIO.Local">Pool</a> -&gt; <a href="../base-4.13.0.0/System-IO.html#t:IO" title="System.IO">IO</a> () <a href="src/Control.Concurrent.ParallelIO.Local.html#spawnPoolWorkerFor" class="link">Source</a> <a href="#v:spawnPoolWorkerFor" class="selflink">#</a></p><div class="doc"><p>Internal method for adding extra unblocked threads to a pool if one of the current
 worker threads is going to be temporarily blocked. Unrestricted use of this is unsafe,
 so we recommend that you use the <code><a href="Control-Concurrent-ParallelIO-Local.html#v:extraWorkerWhileBlocked" title="Control.Concurrent.ParallelIO.Local">extraWorkerWhileBlocked</a></code> function instead if possible.</p></div></div><div class="top"><p class="src"><a id="v:killPoolWorkerFor" class="def">killPoolWorkerFor</a> :: <a href="Control-Concurrent-ParallelIO-Local.html#t:Pool" title="Control.Concurrent.ParallelIO.Local">Pool</a> -&gt; <a href="../base-4.13.0.0/System-IO.html#t:IO" title="System.IO">IO</a> () <a href="src/Control.Concurrent.ParallelIO.Local.html#killPoolWorkerFor" class="link">Source</a> <a href="#v:killPoolWorkerFor" class="selflink">#</a></p><div class="doc"><p>Internal method for removing threads from a pool after one of the threads on the pool
 becomes newly unblocked. Unrestricted use of this is unsafe, so we reccomend that you use
 the <code><a href="Control-Concurrent-ParallelIO-Local.html#v:extraWorkerWhileBlocked" title="Control.Concurrent.ParallelIO.Local">extraWorkerWhileBlocked</a></code> function instead if possible.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.23.0</p></div></body></html>